<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MongoDB C++ Driver: bsoncxx::vector::accessor&lt; Format &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
<!-- patch-apidocs-current-redirects: mongocxx-4.1.3 -->
<link rel="canonical" href="https://mongocxx.org/api/mongocxx-4.1.3/classbsoncxx_1_1vector_1_1accessor.html"/>
<script type="text/javascript">
if (window.location.pathname.startsWith("/api/current/")) {
  window.location.replace(
    window.location.href.replace("/api/current/", "/api/mongocxx-4.1.3/")
  )
}
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MongoDB C++ Driver<span id="projectnumber">&#160;4.1.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacebsoncxx.html">bsoncxx</a></li><li class="navelem"><a href="namespacebsoncxx_1_1vector.html">vector</a></li><li class="navelem"><a href="classbsoncxx_1_1vector_1_1accessor.html">accessor</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbsoncxx_1_1vector_1_1accessor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">bsoncxx::vector::accessor&lt; Format &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="accessor_8hpp_source.html">bsoncxx/v_noabi/bsoncxx/vector/accessor.hpp</a>&gt;</code></p>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Format&gt;<br />
class bsoncxx::vector::accessor&lt; Format &gt;</div><p>Accessor for the contents of a valid BSON Binary Vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Format</td><td>One of the <a class="el" href="namespacebsoncxx_1_1v__noabi_1_1vector_1_1formats.html">bsoncxx::v_noabi::vector::formats</a> types, optionally with a const qualifier.</td></tr>
  </table>
  </dd>
</dl>
<p>This accessor operates on data formatted for the <a class="el" href="namespacebsoncxx_1_1v__noabi.html#a1b36aae294af5ac53b44a962b4dae6ffae9c7d1baa50f42a75d60c1680feaec5e" title="BSON Binary Vector.">bsoncxx::v_noabi::binary_sub_type::k_vector</a> BSON binary subtype. A mutable accessor may be constructed only using <a class="el" href="classbsoncxx_1_1v__noabi_1_1builder_1_1basic_1_1sub__binary.html" title="Represents a BSON Binary element being constructed during an append operation.">bsoncxx::v_noabi::builder::basic::sub_binary</a>. A const accessor may be constructed by validating any <a class="el" href="structbsoncxx_1_1v__noabi_1_1types_1_1b__binary.html" title="A BSON binary data value.">bsoncxx::v_noabi::types::b_binary</a>.</p>
<p>The specific iterator and element types vary for each supported format.</p>
<p><a class="el" href="structbsoncxx_1_1v__noabi_1_1vector_1_1formats_1_1f__float32.html" title="Vector format for 32-bit floating point elements, packed least significant byte first.">bsoncxx::v_noabi::vector::formats::f_float32</a> uses a custom element type to support packed storage with a fixed byte order.</p>
<p><a class="el" href="structbsoncxx_1_1v__noabi_1_1vector_1_1formats_1_1f__packed__bit.html" title="Vector format for single bit elements, packed most significant bit first.">bsoncxx::v_noabi::vector::formats::f_packed_bit</a> uses a custom element and iterator type for single bits that unpacks them as bool. It also has custom element and iterator types for byte access, which serve to mask writes to reserved bits. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7e23285f3c66e53f7e92102c8b64462a" id="r_a7e23285f3c66e53f7e92102c8b64462a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e23285f3c66e53f7e92102c8b64462a">byte_count_type</a></td></tr>
<tr class="memdesc:a7e23285f3c66e53f7e92102c8b64462a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for byte counts.  <br /></td></tr>
<tr class="memitem:a9c9fefa195052a161d4f892e76d94914" id="r_a9c9fefa195052a161d4f892e76d94914"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c9fefa195052a161d4f892e76d94914">byte_difference_type</a></td></tr>
<tr class="memdesc:a9c9fefa195052a161d4f892e76d94914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for signed differences between byte iterators.  <br /></td></tr>
<tr class="memitem:ae6709143a518ef6f23c313ad62931327" id="r_ae6709143a518ef6f23c313ad62931327"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6709143a518ef6f23c313ad62931327">byte_iterator</a></td></tr>
<tr class="memdesc:ae6709143a518ef6f23c313ad62931327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte iterator type.  <br /></td></tr>
<tr class="memitem:a4a1a3b77df74cbeeb75312124df713f2" id="r_a4a1a3b77df74cbeeb75312124df713f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a1a3b77df74cbeeb75312124df713f2">byte_reference</a></td></tr>
<tr class="memdesc:a4a1a3b77df74cbeeb75312124df713f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for referencing vector bytes in-place.  <br /></td></tr>
<tr class="memitem:adda4bd55f2a30251e7178457b8b2df5a" id="r_adda4bd55f2a30251e7178457b8b2df5a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda4bd55f2a30251e7178457b8b2df5a">byte_type</a></td></tr>
<tr class="memdesc:adda4bd55f2a30251e7178457b8b2df5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for the underlying byte data.  <br /></td></tr>
<tr class="memitem:abdc5d6540e5eac5df860e168eadad8d2" id="r_abdc5d6540e5eac5df860e168eadad8d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdc5d6540e5eac5df860e168eadad8d2">const_byte_iterator</a></td></tr>
<tr class="memdesc:abdc5d6540e5eac5df860e168eadad8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for const-qualified vector bytes.  <br /></td></tr>
<tr class="memitem:a3dbad4f0ad40f3c25000f9606ac91f25" id="r_a3dbad4f0ad40f3c25000f9606ac91f25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dbad4f0ad40f3c25000f9606ac91f25">const_byte_reference</a></td></tr>
<tr class="memdesc:a3dbad4f0ad40f3c25000f9606ac91f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for referencing const-qualified vector bytes in-place.  <br /></td></tr>
<tr class="memitem:a15c8a7988ab4154e1d005d38e626f9c9" id="r_a15c8a7988ab4154e1d005d38e626f9c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15c8a7988ab4154e1d005d38e626f9c9">const_iterator</a></td></tr>
<tr class="memdesc:a15c8a7988ab4154e1d005d38e626f9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for const-qualified vector elements.  <br /></td></tr>
<tr class="memitem:af497891649b42a1b90caf67e984bef3b" id="r_af497891649b42a1b90caf67e984bef3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af497891649b42a1b90caf67e984bef3b">const_reference</a></td></tr>
<tr class="memdesc:af497891649b42a1b90caf67e984bef3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for referencing const-qualified vector elements in-place.  <br /></td></tr>
<tr class="memitem:a5eb6be5af0f7a98d35b96385b52cc9de" id="r_a5eb6be5af0f7a98d35b96385b52cc9de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5eb6be5af0f7a98d35b96385b52cc9de">const_value_type</a></td></tr>
<tr class="memdesc:a5eb6be5af0f7a98d35b96385b52cc9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const qualified version of <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html#a3df1d0c4c69d86719d5ff9421740e0f4">value_type</a>.  <br /></td></tr>
<tr class="memitem:a6bcededdd05cb6971d91ea4ddb95bdf0" id="r_a6bcededdd05cb6971d91ea4ddb95bdf0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a></td></tr>
<tr class="memdesc:a6bcededdd05cb6971d91ea4ddb95bdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for element counts.  <br /></td></tr>
<tr class="memitem:ae3cb4139ae8fac0dc9caa52fd1ab4a4a" id="r_ae3cb4139ae8fac0dc9caa52fd1ab4a4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3cb4139ae8fac0dc9caa52fd1ab4a4a">element_difference_type</a></td></tr>
<tr class="memdesc:ae3cb4139ae8fac0dc9caa52fd1ab4a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for signed differences between element iterators.  <br /></td></tr>
<tr class="memitem:a3715968cef2e946ec0df95764d163538" id="r_a3715968cef2e946ec0df95764d163538"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3715968cef2e946ec0df95764d163538">format</a> = Format</td></tr>
<tr class="memdesc:a3715968cef2e946ec0df95764d163538"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type from <a class="el" href="namespacebsoncxx_1_1v__noabi_1_1vector_1_1formats.html" title="Declares supported BSON Binary Vector formats.">bsoncxx::v_noabi::vector::formats</a> representing this vector's layout and element type.  <br /></td></tr>
<tr class="memitem:a80c39edfb3893708f0d6129f2d0dd6cf" id="r_a80c39edfb3893708f0d6129f2d0dd6cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80c39edfb3893708f0d6129f2d0dd6cf">iterator</a></td></tr>
<tr class="memdesc:a80c39edfb3893708f0d6129f2d0dd6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element iterator type.  <br /></td></tr>
<tr class="memitem:a4cd80ca712c149e3c50014dcb212065d" id="r_a4cd80ca712c149e3c50014dcb212065d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cd80ca712c149e3c50014dcb212065d">reference</a></td></tr>
<tr class="memdesc:a4cd80ca712c149e3c50014dcb212065d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for referencing vector elements in-place.  <br /></td></tr>
<tr class="memitem:a3df1d0c4c69d86719d5ff9421740e0f4" id="r_a3df1d0c4c69d86719d5ff9421740e0f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3df1d0c4c69d86719d5ff9421740e0f4">value_type</a></td></tr>
<tr class="memdesc:a3df1d0c4c69d86719d5ff9421740e0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type suitable for holding element values.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15ab13f31d1ca783366f7e5a9fe815b8" id="r_a15ab13f31d1ca783366f7e5a9fe815b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15ab13f31d1ca783366f7e5a9fe815b8">accessor</a> (<a class="el" href="structbsoncxx_1_1v__noabi_1_1types_1_1b__binary.html">types::b_binary</a> const &amp;binary)</td></tr>
<tr class="memdesc:a15ab13f31d1ca783366f7e5a9fe815b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const vector accessor by validating a <a class="el" href="structbsoncxx_1_1v__noabi_1_1types_1_1b__binary.html" title="A BSON binary data value.">bsoncxx::v_noabi::types::b_binary</a> reference.  <br /></td></tr>
<tr class="memitem:ae33b267cc5a7bd83c39276de5dffed70" id="r_ae33b267cc5a7bd83c39276de5dffed70"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">accessor</a>&lt; <a class="el" href="#a3715968cef2e946ec0df95764d163538">format</a> const &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33b267cc5a7bd83c39276de5dffed70">as_const</a> () const noexcept</td></tr>
<tr class="memdesc:ae33b267cc5a7bd83c39276de5dffed70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const version of this vector accessor, without re-validating the vector data.  <br /></td></tr>
<tr class="memitem:a177095831dea17663241e973c49183c5" id="r_a177095831dea17663241e973c49183c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4cd80ca712c149e3c50014dcb212065d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a177095831dea17663241e973c49183c5">at</a> (<a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a> index)</td></tr>
<tr class="memdesc:a177095831dea17663241e973c49183c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to a numbered element, with bounds checking.  <br /></td></tr>
<tr class="memitem:a10a739d95772b0b1a7e97767c87d9e8e" id="r_a10a739d95772b0b1a7e97767c87d9e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af497891649b42a1b90caf67e984bef3b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a739d95772b0b1a7e97767c87d9e8e">at</a> (<a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a> index) const</td></tr>
<tr class="memdesc:a10a739d95772b0b1a7e97767c87d9e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const reference to a numbered element, with bounds checking.  <br /></td></tr>
<tr class="memitem:a5530b5945f7dc1776d28bf66a99ff914" id="r_a5530b5945f7dc1776d28bf66a99ff914"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af497891649b42a1b90caf67e984bef3b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5530b5945f7dc1776d28bf66a99ff914">back</a> () const noexcept</td></tr>
<tr class="memdesc:a5530b5945f7dc1776d28bf66a99ff914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const reference to the last element.  <br /></td></tr>
<tr class="memitem:ada08d7adae235395b5cefe3a351dfe3c" id="r_ada08d7adae235395b5cefe3a351dfe3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4cd80ca712c149e3c50014dcb212065d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada08d7adae235395b5cefe3a351dfe3c">back</a> () noexcept</td></tr>
<tr class="memdesc:ada08d7adae235395b5cefe3a351dfe3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the last element.  <br /></td></tr>
<tr class="memitem:a20a26878803c521c894c3d3f586c8fcb" id="r_a20a26878803c521c894c3d3f586c8fcb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a80c39edfb3893708f0d6129f2d0dd6cf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20a26878803c521c894c3d3f586c8fcb">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a20a26878803c521c894c3d3f586c8fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a per-element iterator pointing to the beginning of the vector.  <br /></td></tr>
<tr class="memitem:a1b31935b17918b52fc15b692f79a2b2b" id="r_a1b31935b17918b52fc15b692f79a2b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4a1a3b77df74cbeeb75312124df713f2">byte_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b31935b17918b52fc15b692f79a2b2b">byte_at</a> (<a class="el" href="#a7e23285f3c66e53f7e92102c8b64462a">byte_count_type</a> index)</td></tr>
<tr class="memdesc:a1b31935b17918b52fc15b692f79a2b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to a numbered byte, with bounds checking.  <br /></td></tr>
<tr class="memitem:a47c9dc77546d2c8d5565fb3e2b4d7eff" id="r_a47c9dc77546d2c8d5565fb3e2b4d7eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3dbad4f0ad40f3c25000f9606ac91f25">const_byte_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47c9dc77546d2c8d5565fb3e2b4d7eff">byte_at</a> (<a class="el" href="#a7e23285f3c66e53f7e92102c8b64462a">byte_count_type</a> index) const</td></tr>
<tr class="memdesc:a47c9dc77546d2c8d5565fb3e2b4d7eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const reference to a numbered byte, with bounds checking.  <br /></td></tr>
<tr class="memitem:a3973b8290b80387a6b07c7011371c61e" id="r_a3973b8290b80387a6b07c7011371c61e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a3dbad4f0ad40f3c25000f9606ac91f25">const_byte_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3973b8290b80387a6b07c7011371c61e">byte_back</a> () const noexcept</td></tr>
<tr class="memdesc:a3973b8290b80387a6b07c7011371c61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const reference to the last byte.  <br /></td></tr>
<tr class="memitem:a421041d21cf7d24987e513559e398374" id="r_a421041d21cf7d24987e513559e398374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4a1a3b77df74cbeeb75312124df713f2">byte_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a421041d21cf7d24987e513559e398374">byte_back</a> () noexcept</td></tr>
<tr class="memdesc:a421041d21cf7d24987e513559e398374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the last byte.  <br /></td></tr>
<tr class="memitem:a4236ca836e904ecdedfdf0e4a5e07609" id="r_a4236ca836e904ecdedfdf0e4a5e07609"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae6709143a518ef6f23c313ad62931327">byte_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4236ca836e904ecdedfdf0e4a5e07609">byte_begin</a> () const noexcept</td></tr>
<tr class="memdesc:a4236ca836e904ecdedfdf0e4a5e07609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a per-byte iterator pointing to the beginning of the vector.  <br /></td></tr>
<tr class="memitem:a451d192493e22c2239f39ccb3cda9b68" id="r_a451d192493e22c2239f39ccb3cda9b68"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#abdc5d6540e5eac5df860e168eadad8d2">const_byte_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a451d192493e22c2239f39ccb3cda9b68">byte_cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a451d192493e22c2239f39ccb3cda9b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const per-byte iterator pointing to the beginning of the vector.  <br /></td></tr>
<tr class="memitem:ae7080f556157258e74b1c1833cd520f3" id="r_ae7080f556157258e74b1c1833cd520f3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#abdc5d6540e5eac5df860e168eadad8d2">const_byte_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7080f556157258e74b1c1833cd520f3">byte_cend</a> () const noexcept</td></tr>
<tr class="memdesc:ae7080f556157258e74b1c1833cd520f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const per-byte end iterator.  <br /></td></tr>
<tr class="memitem:acd21c07a6521a2ca363f159238a16afd" id="r_acd21c07a6521a2ca363f159238a16afd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae6709143a518ef6f23c313ad62931327">byte_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd21c07a6521a2ca363f159238a16afd">byte_end</a> () const noexcept</td></tr>
<tr class="memdesc:acd21c07a6521a2ca363f159238a16afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a per-byte end iterator.  <br /></td></tr>
<tr class="memitem:a24ea3005bad7a694699dd2f1158aa738" id="r_a24ea3005bad7a694699dd2f1158aa738"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a3dbad4f0ad40f3c25000f9606ac91f25">const_byte_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24ea3005bad7a694699dd2f1158aa738">byte_front</a> () const noexcept</td></tr>
<tr class="memdesc:a24ea3005bad7a694699dd2f1158aa738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const reference to the first byte.  <br /></td></tr>
<tr class="memitem:abecf0e409c739e1722d927ce292e54b9" id="r_abecf0e409c739e1722d927ce292e54b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4a1a3b77df74cbeeb75312124df713f2">byte_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abecf0e409c739e1722d927ce292e54b9">byte_front</a> () noexcept</td></tr>
<tr class="memdesc:abecf0e409c739e1722d927ce292e54b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the first byte.  <br /></td></tr>
<tr class="memitem:a404bf9908b5f1c4e8e5c32c0451f829a" id="r_a404bf9908b5f1c4e8e5c32c0451f829a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a7e23285f3c66e53f7e92102c8b64462a">byte_count_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a404bf9908b5f1c4e8e5c32c0451f829a">byte_size</a> () const noexcept</td></tr>
<tr class="memdesc:a404bf9908b5f1c4e8e5c32c0451f829a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the bytes of element data, not including any headers.  <br /></td></tr>
<tr class="memitem:ac2cd9c4a4c1e821b641f5a31791a4576" id="r_ac2cd9c4a4c1e821b641f5a31791a4576"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15c8a7988ab4154e1d005d38e626f9c9">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2cd9c4a4c1e821b641f5a31791a4576">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:ac2cd9c4a4c1e821b641f5a31791a4576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const per-element iterator pointing to the beginning of the vector.  <br /></td></tr>
<tr class="memitem:a57a7e93eb5db7a50d43958b787b82e9f" id="r_a57a7e93eb5db7a50d43958b787b82e9f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15c8a7988ab4154e1d005d38e626f9c9">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57a7e93eb5db7a50d43958b787b82e9f">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a57a7e93eb5db7a50d43958b787b82e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const per-element end iterator.  <br /></td></tr>
<tr class="memitem:a522f09ede9520d655c482d4cd2d51960" id="r_a522f09ede9520d655c482d4cd2d51960"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a522f09ede9520d655c482d4cd2d51960">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a522f09ede9520d655c482d4cd2d51960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the vector is empty.  <br /></td></tr>
<tr class="memitem:af5a0478bc28f6b01748de31bca61c488" id="r_af5a0478bc28f6b01748de31bca61c488"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a80c39edfb3893708f0d6129f2d0dd6cf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5a0478bc28f6b01748de31bca61c488">end</a> () const noexcept</td></tr>
<tr class="memdesc:af5a0478bc28f6b01748de31bca61c488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a per-element end iterator.  <br /></td></tr>
<tr class="memitem:a798fa7c8fab788b44e5e81abe96ad40a" id="r_a798fa7c8fab788b44e5e81abe96ad40a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af497891649b42a1b90caf67e984bef3b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a798fa7c8fab788b44e5e81abe96ad40a">front</a> () const noexcept</td></tr>
<tr class="memdesc:a798fa7c8fab788b44e5e81abe96ad40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const reference to the first element.  <br /></td></tr>
<tr class="memitem:aff37c287230b0205d05338109edd6db4" id="r_aff37c287230b0205d05338109edd6db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4cd80ca712c149e3c50014dcb212065d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff37c287230b0205d05338109edd6db4">front</a> () noexcept</td></tr>
<tr class="memdesc:aff37c287230b0205d05338109edd6db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the first element.  <br /></td></tr>
<tr class="memitem:a462cfd444f4377626816131104e473f2" id="r_a462cfd444f4377626816131104e473f2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#af497891649b42a1b90caf67e984bef3b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a462cfd444f4377626816131104e473f2">operator[]</a> (<a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a> index) const noexcept</td></tr>
<tr class="memdesc:a462cfd444f4377626816131104e473f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a const reference to a numbered element, without bounds checking.  <br /></td></tr>
<tr class="memitem:a54fc930c85b213535a8d11ee1946c1ea" id="r_a54fc930c85b213535a8d11ee1946c1ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4cd80ca712c149e3c50014dcb212065d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54fc930c85b213535a8d11ee1946c1ea">operator[]</a> (<a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a> index) noexcept</td></tr>
<tr class="memdesc:a54fc930c85b213535a8d11ee1946c1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to a numbered element, without bounds checking.  <br /></td></tr>
<tr class="memitem:a5ba173b2c0f4bff45c01ed84bdeff640" id="r_a5ba173b2c0f4bff45c01ed84bdeff640"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ba173b2c0f4bff45c01ed84bdeff640">size</a> () const noexcept</td></tr>
<tr class="memdesc:a5ba173b2c0f4bff45c01ed84bdeff640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of elements.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a553b263f53873d41b03a47e41e392f62" id="r_a553b263f53873d41b03a47e41e392f62"><td class="memItemLeft" align="right" valign="top"><a id="a553b263f53873d41b03a47e41e392f62" name="a553b263f53873d41b03a47e41e392f62"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>bsoncxx::v_noabi::builder::basic::sub_binary</b></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a7e23285f3c66e53f7e92102c8b64462a" name="a7e23285f3c66e53f7e92102c8b64462a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e23285f3c66e53f7e92102c8b64462a">&#9670;&#160;</a></span>byte_count_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_count_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for byte counts. </p>
<p>For example: std::uint32_t, due to BSON size limits. </p>

</div>
</div>
<a id="a9c9fefa195052a161d4f892e76d94914" name="a9c9fefa195052a161d4f892e76d94914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9fefa195052a161d4f892e76d94914">&#9670;&#160;</a></span>byte_difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for signed differences between byte iterators. </p>
<p>For example: std::ptrdiff_t </p>

</div>
</div>
<a id="ae6709143a518ef6f23c313ad62931327" name="ae6709143a518ef6f23c313ad62931327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6709143a518ef6f23c313ad62931327">&#9670;&#160;</a></span>byte_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte iterator type. </p>
<p>For example: std::uint8_t*, std::uint8_t const*, <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1iterators_1_1packed__bit__byte.html" title="Iterator for bytes within a packed_bit vector.">bsoncxx::v_noabi::vector::iterators::packed_bit_byte</a> </p>

</div>
</div>
<a id="a4a1a3b77df74cbeeb75312124df713f2" name="a4a1a3b77df74cbeeb75312124df713f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1a3b77df74cbeeb75312124df713f2">&#9670;&#160;</a></span>byte_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for referencing vector bytes in-place. </p>
<p>For example: std::uint8_t&amp;, std::uint8_t const&amp;, <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1elements_1_1packed__bit__byte.html" title="Reference to a byte or partial byte within a vector of packed_bit elements. Allows access to each byt...">bsoncxx::v_noabi::vector::elements::packed_bit_byte</a> </p>

</div>
</div>
<a id="adda4bd55f2a30251e7178457b8b2df5a" name="adda4bd55f2a30251e7178457b8b2df5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda4bd55f2a30251e7178457b8b2df5a">&#9670;&#160;</a></span>byte_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for the underlying byte data. </p>
<p>For example: std::uint8_t, std::uint8_t const </p>

</div>
</div>
<a id="abdc5d6540e5eac5df860e168eadad8d2" name="abdc5d6540e5eac5df860e168eadad8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc5d6540e5eac5df860e168eadad8d2">&#9670;&#160;</a></span>const_byte_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::const_byte_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator for const-qualified vector bytes. </p>

</div>
</div>
<a id="a3dbad4f0ad40f3c25000f9606ac91f25" name="a3dbad4f0ad40f3c25000f9606ac91f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbad4f0ad40f3c25000f9606ac91f25">&#9670;&#160;</a></span>const_byte_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::const_byte_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for referencing const-qualified vector bytes in-place. </p>

</div>
</div>
<a id="a15c8a7988ab4154e1d005d38e626f9c9" name="a15c8a7988ab4154e1d005d38e626f9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c8a7988ab4154e1d005d38e626f9c9">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator for const-qualified vector elements. </p>

</div>
</div>
<a id="af497891649b42a1b90caf67e984bef3b" name="af497891649b42a1b90caf67e984bef3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af497891649b42a1b90caf67e984bef3b">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for referencing const-qualified vector elements in-place. </p>

</div>
</div>
<a id="a5eb6be5af0f7a98d35b96385b52cc9de" name="a5eb6be5af0f7a98d35b96385b52cc9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb6be5af0f7a98d35b96385b52cc9de">&#9670;&#160;</a></span>const_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::const_value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const qualified version of <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html#a3df1d0c4c69d86719d5ff9421740e0f4">value_type</a>. </p>

</div>
</div>
<a id="a6bcededdd05cb6971d91ea4ddb95bdf0" name="a6bcededdd05cb6971d91ea4ddb95bdf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcededdd05cb6971d91ea4ddb95bdf0">&#9670;&#160;</a></span>element_count_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::element_count_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for element counts. </p>
<p>For example: std::size_t </p>

</div>
</div>
<a id="ae3cb4139ae8fac0dc9caa52fd1ab4a4a" name="ae3cb4139ae8fac0dc9caa52fd1ab4a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cb4139ae8fac0dc9caa52fd1ab4a4a">&#9670;&#160;</a></span>element_difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::element_difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for signed differences between element iterators. </p>
<p>For example: std::ptrdiff_t </p>

</div>
</div>
<a id="a3715968cef2e946ec0df95764d163538" name="a3715968cef2e946ec0df95764d163538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3715968cef2e946ec0df95764d163538">&#9670;&#160;</a></span>format</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::format = Format</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type from <a class="el" href="namespacebsoncxx_1_1v__noabi_1_1vector_1_1formats.html" title="Declares supported BSON Binary Vector formats.">bsoncxx::v_noabi::vector::formats</a> representing this vector's layout and element type. </p>

</div>
</div>
<a id="a80c39edfb3893708f0d6129f2d0dd6cf" name="a80c39edfb3893708f0d6129f2d0dd6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c39edfb3893708f0d6129f2d0dd6cf">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element iterator type. </p>
<p>For example: std::int8_t*, <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1elements_1_1float32.html" title="A 32-bit float value in packed little-endian format.">bsoncxx::v_noabi::vector::elements::float32</a>*, <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1iterators_1_1packed__bit__element.html" title="Iterator for elements within a packed_bit vector.">bsoncxx::v_noabi::vector::iterators::packed_bit_element</a> </p>

</div>
</div>
<a id="a4cd80ca712c149e3c50014dcb212065d" name="a4cd80ca712c149e3c50014dcb212065d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd80ca712c149e3c50014dcb212065d">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for referencing vector elements in-place. </p>
<p>For example: std::int8_t&amp;, <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1elements_1_1float32.html" title="A 32-bit float value in packed little-endian format.">bsoncxx::v_noabi::vector::elements::float32</a>&amp;, <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1elements_1_1packed__bit__element.html" title="Reference to a single element in a packed_bit vector.">bsoncxx::v_noabi::vector::elements::packed_bit_element</a> </p>

</div>
</div>
<a id="a3df1d0c4c69d86719d5ff9421740e0f4" name="a3df1d0c4c69d86719d5ff9421740e0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df1d0c4c69d86719d5ff9421740e0f4">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type suitable for holding element values. </p>
<p>For example: std::int8_t, float, bool </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a15ab13f31d1ca783366f7e5a9fe815b8" name="a15ab13f31d1ca783366f7e5a9fe815b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ab13f31d1ca783366f7e5a9fe815b8">&#9670;&#160;</a></span>accessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::accessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsoncxx_1_1v__noabi_1_1types_1_1b__binary.html">types::b_binary</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>binary</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const vector accessor by validating a <a class="el" href="structbsoncxx_1_1v__noabi_1_1types_1_1b__binary.html" title="A BSON binary data value.">bsoncxx::v_noabi::types::b_binary</a> reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary</td><td>Non-owning reference to BSON binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbsoncxx_1_1v__noabi_1_1exception.html" title="Base class for all exceptions thrown by the bsoncxx library unless otherwise specified.">bsoncxx::v_noabi::exception</a></td><td>with <a class="el" href="namespacebsoncxx_1_1v__noabi.html#a217902599bbc7208f4db7611bae2c5b9acb9f2060b00a27a86cdc5d16c870b9ae" title="A BSON Binary Vector failed to parse in the requested format.">bsoncxx::v_noabi::error_code::k_invalid_vector</a>, if validation fails.</td></tr>
  </table>
  </dd>
</dl>
<p>The Binary data is validated as a vector of the templated Format. On success, an accessor is created which references the same data as the <a class="el" href="structbsoncxx_1_1v__noabi_1_1types_1_1b__binary.html" title="A BSON binary data value.">bsoncxx::v_noabi::types::b_binary</a> pointer. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ae33b267cc5a7bd83c39276de5dffed70" name="ae33b267cc5a7bd83c39276de5dffed70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33b267cc5a7bd83c39276de5dffed70">&#9670;&#160;</a></span>as_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">accessor</a>&lt; <a class="el" href="#a3715968cef2e946ec0df95764d163538">format</a> const  &gt; <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::as_const </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const version of this vector accessor, without re-validating the vector data. </p>

</div>
</div>
<a id="a177095831dea17663241e973c49183c5" name="a177095831dea17663241e973c49183c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177095831dea17663241e973c49183c5">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4cd80ca712c149e3c50014dcb212065d">reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a reference to a numbered element, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index in the range 0 to <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html#a5ba173b2c0f4bff45c01ed84bdeff640" title="Count the number of elements.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbsoncxx_1_1v__noabi_1_1exception.html" title="Base class for all exceptions thrown by the bsoncxx library unless otherwise specified.">bsoncxx::v_noabi::exception</a></td><td>with <a class="el" href="namespacebsoncxx_1_1v__noabi.html#a217902599bbc7208f4db7611bae2c5b9af1cc626787e5ae79be045c87f20bdeef" title="Attempted out-of-range access to a BSON Binary Vector element.">bsoncxx::v_noabi::error_code::k_vector_out_of_range</a>, if the index is outside the allowed range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10a739d95772b0b1a7e97767c87d9e8e" name="a10a739d95772b0b1a7e97767c87d9e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a739d95772b0b1a7e97767c87d9e8e">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af497891649b42a1b90caf67e984bef3b">const_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const reference to a numbered element, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index in the range 0 to <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html#a5ba173b2c0f4bff45c01ed84bdeff640" title="Count the number of elements.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbsoncxx_1_1v__noabi_1_1exception.html" title="Base class for all exceptions thrown by the bsoncxx library unless otherwise specified.">bsoncxx::v_noabi::exception</a></td><td>with <a class="el" href="namespacebsoncxx_1_1v__noabi.html#a217902599bbc7208f4db7611bae2c5b9af1cc626787e5ae79be045c87f20bdeef" title="Attempted out-of-range access to a BSON Binary Vector element.">bsoncxx::v_noabi::error_code::k_vector_out_of_range</a>, if the index is outside the allowed range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5530b5945f7dc1776d28bf66a99ff914" name="a5530b5945f7dc1776d28bf66a99ff914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5530b5945f7dc1776d28bf66a99ff914">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af497891649b42a1b90caf67e984bef3b">const_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const reference to the last element. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the vector is empty. </dd></dl>

</div>
</div>
<a id="ada08d7adae235395b5cefe3a351dfe3c" name="ada08d7adae235395b5cefe3a351dfe3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada08d7adae235395b5cefe3a351dfe3c">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4cd80ca712c149e3c50014dcb212065d">reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a reference to the last element. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the vector is empty. </dd></dl>

</div>
</div>
<a id="a20a26878803c521c894c3d3f586c8fcb" name="a20a26878803c521c894c3d3f586c8fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a26878803c521c894c3d3f586c8fcb">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a80c39edfb3893708f0d6129f2d0dd6cf">iterator</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a per-element iterator pointing to the beginning of the vector. </p>

</div>
</div>
<a id="a1b31935b17918b52fc15b692f79a2b2b" name="a1b31935b17918b52fc15b692f79a2b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b31935b17918b52fc15b692f79a2b2b">&#9670;&#160;</a></span>byte_at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4a1a3b77df74cbeeb75312124df713f2">byte_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7e23285f3c66e53f7e92102c8b64462a">byte_count_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a reference to a numbered byte, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index in the range 0 to <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html#a404bf9908b5f1c4e8e5c32c0451f829a" title="Count the bytes of element data, not including any headers.">byte_size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbsoncxx_1_1v__noabi_1_1exception.html" title="Base class for all exceptions thrown by the bsoncxx library unless otherwise specified.">bsoncxx::v_noabi::exception</a></td><td>with <a class="el" href="namespacebsoncxx_1_1v__noabi.html#a217902599bbc7208f4db7611bae2c5b9af1cc626787e5ae79be045c87f20bdeef" title="Attempted out-of-range access to a BSON Binary Vector element.">bsoncxx::v_noabi::error_code::k_vector_out_of_range</a>, if the index is outside the allowed range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47c9dc77546d2c8d5565fb3e2b4d7eff" name="a47c9dc77546d2c8d5565fb3e2b4d7eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c9dc77546d2c8d5565fb3e2b4d7eff">&#9670;&#160;</a></span>byte_at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3dbad4f0ad40f3c25000f9606ac91f25">const_byte_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7e23285f3c66e53f7e92102c8b64462a">byte_count_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const reference to a numbered byte, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index in the range 0 to <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html#a404bf9908b5f1c4e8e5c32c0451f829a" title="Count the bytes of element data, not including any headers.">byte_size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbsoncxx_1_1v__noabi_1_1exception.html" title="Base class for all exceptions thrown by the bsoncxx library unless otherwise specified.">bsoncxx::v_noabi::exception</a></td><td>with <a class="el" href="namespacebsoncxx_1_1v__noabi.html#a217902599bbc7208f4db7611bae2c5b9af1cc626787e5ae79be045c87f20bdeef" title="Attempted out-of-range access to a BSON Binary Vector element.">bsoncxx::v_noabi::error_code::k_vector_out_of_range</a>, if the index is outside the allowed range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3973b8290b80387a6b07c7011371c61e" name="a3973b8290b80387a6b07c7011371c61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3973b8290b80387a6b07c7011371c61e">&#9670;&#160;</a></span>byte_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3dbad4f0ad40f3c25000f9606ac91f25">const_byte_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const reference to the last byte. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the vector is empty. </dd></dl>

</div>
</div>
<a id="a421041d21cf7d24987e513559e398374" name="a421041d21cf7d24987e513559e398374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421041d21cf7d24987e513559e398374">&#9670;&#160;</a></span>byte_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4a1a3b77df74cbeeb75312124df713f2">byte_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a reference to the last byte. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the vector is empty. </dd></dl>

</div>
</div>
<a id="a4236ca836e904ecdedfdf0e4a5e07609" name="a4236ca836e904ecdedfdf0e4a5e07609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4236ca836e904ecdedfdf0e4a5e07609">&#9670;&#160;</a></span>byte_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae6709143a518ef6f23c313ad62931327">byte_iterator</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a per-byte iterator pointing to the beginning of the vector. </p>

</div>
</div>
<a id="a451d192493e22c2239f39ccb3cda9b68" name="a451d192493e22c2239f39ccb3cda9b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451d192493e22c2239f39ccb3cda9b68">&#9670;&#160;</a></span>byte_cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abdc5d6540e5eac5df860e168eadad8d2">const_byte_iterator</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const per-byte iterator pointing to the beginning of the vector. </p>

</div>
</div>
<a id="ae7080f556157258e74b1c1833cd520f3" name="ae7080f556157258e74b1c1833cd520f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7080f556157258e74b1c1833cd520f3">&#9670;&#160;</a></span>byte_cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abdc5d6540e5eac5df860e168eadad8d2">const_byte_iterator</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const per-byte end iterator. </p>

</div>
</div>
<a id="acd21c07a6521a2ca363f159238a16afd" name="acd21c07a6521a2ca363f159238a16afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd21c07a6521a2ca363f159238a16afd">&#9670;&#160;</a></span>byte_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae6709143a518ef6f23c313ad62931327">byte_iterator</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a per-byte end iterator. </p>

</div>
</div>
<a id="a24ea3005bad7a694699dd2f1158aa738" name="a24ea3005bad7a694699dd2f1158aa738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ea3005bad7a694699dd2f1158aa738">&#9670;&#160;</a></span>byte_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3dbad4f0ad40f3c25000f9606ac91f25">const_byte_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const reference to the first byte. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the vector is empty. </dd></dl>

</div>
</div>
<a id="abecf0e409c739e1722d927ce292e54b9" name="abecf0e409c739e1722d927ce292e54b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecf0e409c739e1722d927ce292e54b9">&#9670;&#160;</a></span>byte_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4a1a3b77df74cbeeb75312124df713f2">byte_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a reference to the first byte. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the vector is empty. </dd></dl>

</div>
</div>
<a id="a404bf9908b5f1c4e8e5c32c0451f829a" name="a404bf9908b5f1c4e8e5c32c0451f829a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404bf9908b5f1c4e8e5c32c0451f829a">&#9670;&#160;</a></span>byte_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7e23285f3c66e53f7e92102c8b64462a">byte_count_type</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::byte_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the bytes of element data, not including any headers. </p>

</div>
</div>
<a id="ac2cd9c4a4c1e821b641f5a31791a4576" name="ac2cd9c4a4c1e821b641f5a31791a4576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cd9c4a4c1e821b641f5a31791a4576">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15c8a7988ab4154e1d005d38e626f9c9">const_iterator</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const per-element iterator pointing to the beginning of the vector. </p>

</div>
</div>
<a id="a57a7e93eb5db7a50d43958b787b82e9f" name="a57a7e93eb5db7a50d43958b787b82e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a7e93eb5db7a50d43958b787b82e9f">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15c8a7988ab4154e1d005d38e626f9c9">const_iterator</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const per-element end iterator. </p>

</div>
</div>
<a id="a522f09ede9520d655c482d4cd2d51960" name="a522f09ede9520d655c482d4cd2d51960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522f09ede9520d655c482d4cd2d51960">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the vector is empty. </p>

</div>
</div>
<a id="af5a0478bc28f6b01748de31bca61c488" name="af5a0478bc28f6b01748de31bca61c488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a0478bc28f6b01748de31bca61c488">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a80c39edfb3893708f0d6129f2d0dd6cf">iterator</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a per-element end iterator. </p>

</div>
</div>
<a id="a798fa7c8fab788b44e5e81abe96ad40a" name="a798fa7c8fab788b44e5e81abe96ad40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798fa7c8fab788b44e5e81abe96ad40a">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af497891649b42a1b90caf67e984bef3b">const_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const reference to the first element. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the vector is empty. </dd></dl>

</div>
</div>
<a id="aff37c287230b0205d05338109edd6db4" name="aff37c287230b0205d05338109edd6db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff37c287230b0205d05338109edd6db4">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4cd80ca712c149e3c50014dcb212065d">reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a reference to the first element. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the vector is empty. </dd></dl>

</div>
</div>
<a id="a462cfd444f4377626816131104e473f2" name="a462cfd444f4377626816131104e473f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462cfd444f4377626816131104e473f2">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af497891649b42a1b90caf67e984bef3b">const_reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a const reference to a numbered element, without bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index in the range 0 to <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html#a5ba173b2c0f4bff45c01ed84bdeff640" title="Count the number of elements.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the index is out of bounds. </dd></dl>

</div>
</div>
<a id="a54fc930c85b213535a8d11ee1946c1ea" name="a54fc930c85b213535a8d11ee1946c1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fc930c85b213535a8d11ee1946c1ea">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4cd80ca712c149e3c50014dcb212065d">reference</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a reference to a numbered element, without bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index in the range 0 to <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html#a5ba173b2c0f4bff45c01ed84bdeff640" title="Count the number of elements.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior if the index is out of bounds. </dd></dl>

</div>
</div>
<a id="a5ba173b2c0f4bff45c01ed84bdeff640" name="a5ba173b2c0f4bff45c01ed84bdeff640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba173b2c0f4bff45c01ed84bdeff640">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Format&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6bcededdd05cb6971d91ea4ddb95bdf0">element_count_type</a> <a class="el" href="classbsoncxx_1_1v__noabi_1_1vector_1_1accessor.html">bsoncxx::v_noabi::vector::accessor</a>&lt; Format &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of elements. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>bsoncxx/v_noabi/bsoncxx/vector/<a class="el" href="accessor-fwd_8hpp_source.html">accessor-fwd.hpp</a></li>
<li>bsoncxx/v_noabi/bsoncxx/vector/<a class="el" href="accessor_8hpp_source.html">accessor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
